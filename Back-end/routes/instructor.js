require('dotenv').config({ path: '../.env' });
const express = require('express');
const db = require('../db/connection');
const authenticateToken = require('../middleware/authmid');
const { logEvent } = require('../utils/audit_logs.js');
const joi = require('joi');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const jwtSecret = process.env.JWT_SECRET;
const router = express.Router();
router.use(authenticateToken);

// generate jwt token
function generateToken (user) {
    return jwt.sign({
        id: user.id,
        username: user.username,
        is_instructor: user.is_instructor
    }, jwtSecret, { expiresIn: '1h' });
}

// joi schemas
const acceptLinkSchema = joi.object({
    token: joi.string().min(32).required().messages({
        'string.min': 'Token must be at least 32 characters',
        'any.required': 'Token is required'
    })
});

const deleteLinkSchema = joi.object({
    linkId: joi.number().integer().required().messages({
        'number.base': 'Link ID must be a number',
        'any.required': 'Link ID is required'
    })
});

const createCommentSchema = joi.object({
    comment_text: joi.string().min(1).max(500).required().messages({
        'string.min': 'Comment must be at least 1 character',
        'string.max': 'Comment must be at most 500 characters',
        'any.required': 'Comment text is required'
    })
});

const updateCommentSchema = createCommentSchema;

// helper for joi error handling
const handleJoiError = (error) => {
    return error.details.map((detail) => ({
        field: detail.context.key,
        message: detail.message,
    }));
};

// helper check if authorized instructor
function isAuthorized(req, targetUserId) {
    if (req.user.id === targetUserId) return true;
    if (req.user.is_instructor !== 1) return false;
    const link = db.prepare(`
        SELECT * FROM user_instructor_links
        WHERE user_id = ? AND instructor_id = ? AND expires_at > CURRENT_TIMESTAMP
    `).get(targetUserId, req.user.id);
    return !!link;
}

// generate link token (allowing all users, including those who are instructors themselves)
router.post('/link/generate', (req, res) => {
    try{
        let token;
        let unique = false;
        while (!unique) {
            token = crypto.randomBytes(16).toString('hex');
            // checking if at least one row has the same token
            const existing = db.prepare(`
                SELECT 1 FROM user_instructor_links WHERE token = ?
            `).get(token);
            if (!existing) unique = true;
        }

        const result = db.prepare(`
            INSERT INTO user_instructor_links (user_id, token, expires_at)
            VALUES (?, ?, datetime('now', '+30 days'))
        `).run(req.user.id, token);

        const link = db.prepare(`
            SELECT expires_at FROM user_instructor_links WHERE id = ?
        `).get(result.lastInsertRowid);

        logEvent(req.user.id, 'link_token_generated', `Link token generated by user ${req.user.username}`, req.ip);
        res.json({ token, expires_at: link.expires_at, message: 'Token generated successfully. Share it with your instructor.' });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// become an instructor
router.put('/become', (req, res) => {
    if (req.user.is_instructor === 1) return res.status(400).json({ error: { field: 'general', message: 'You are already an instructor' } });

    try {
        db.prepare(`
            UPDATE users SET is_instructor = 1 WHERE id = ?
        `).run(req.user.id);

        // 查询最新 user 数据
        const updatedUser = db.prepare('SELECT id, username, is_instructor FROM users WHERE id = ?').get(req.user.id);

        // 生成新 token（假设 generateToken 函数使用 updatedUser）
        const newToken = generateToken(updatedUser);  // 更新 payload 包含 is_instructor: 1

        logEvent(req.user.id, 'became_instructor', `User ${req.user.username} became an instructor`, req.ip);
        res.json({
            message: 'You are now an instructor',
            token: newToken,
            user: updatedUser
        });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// accept link (only as an instructor)
router.post('/link/accept', (req, res) => {
    if (req.user.is_instructor !== 1) {
        return res.status(403).json({ error: { field: 'general', message: 'Please become an instructor first' } });
    }

    const { token } = req.body;
    const { error } = acceptLinkSchema.validate(req.body);
    if (error) return res.status(400).json({ errors: handleJoiError(error) });

    try {
        const link = db.prepare(`
            SELECT id, user_id FROM user_instructor_links
            WHERE token = ? AND instructor_id IS NULL AND expires_at > CURRENT_TIMESTAMP
        `).get(token);

        if (!link) return res.status(404).json({ error: { field: 'general', message: 'Invalid or expired token' } });

        db.prepare(`
            UPDATE user_instructor_links SET instructor_id = ? WHERE id = ?
        `).run(req.user.id, link.id);

        logEvent(req.user.id, 'link_accepted', `Link accepted for user ${link.user_id} by instructor ${req.user.username}`, req.ip);
        res.json({ message: 'Link accepted successfully' });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// list all trainees for an instructor
router.get('/trainee', (req, res) => {
    try {
        const trainees = db.prepare(`
            SELECT l.id AS link_id, l.user_id AS linked_id, u.username, l.created_at, l.expires_at
            FROM user_instructor_links l
            JOIN users u ON u.id = l.user_id
            WHERE l.instructor_id = ? AND l.expires_at > CURRENT_TIMESTAMP
        `).all(req.user.id);

        logEvent(req.user.id, 'links_listed', `Links listed for user ${req.user.username}`, req.ip);
        res.json({ trainees });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// list all instructors for a user
router.get('/instructorsList', (req, res) => {
    try {
        const instructors = db.prepare(`
            SELECT l.id AS link_id, u.username, l.created_at, l.expires_at
            FROM user_instructor_links l
            JOIN users u ON u.id = l.instructor_id
            WHERE l.user_id = ? AND l.expires_at > CURRENT_TIMESTAMP
        `).all(req.user.id);

        logEvent(req.user.id, 'links_listed', `Links listed for user ${req.user.username}`, req.ip);
        res.json({ instructors });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// cancel link (both user and instructor can cancel the link)
router.delete('/link/:linkId', (req, res) => {
    const { linkId } = req.params;
    const { error } = deleteLinkSchema.validate({ linkId: parseInt(linkId) });
    if (error) return res.status(400).json({ errors: handleJoiError(error) });

    try {
        const link = db.prepare(`
            SELECT user_id, instructor_id FROM user_instructor_links
            WHERE id = ? AND expires_at > CURRENT_TIMESTAMP
        `).get(linkId);
        if (!link) return res.status(404).json({ error: { field: 'general', message: 'Link not found' } });
        
        if (req.user.id !== link.user_id && req.user.id !== link.instructor_id) {
            return res.status(403).json({ error: { field: 'general', message: 'Unauthorized to cancel this link' } });
        }

        db.prepare(`DELETE FROM user_instructor_links WHERE id = ?`).run(linkId);

        logEvent(req.user.id, 'link_cancelled', `Link ${linkId} cancelled by user ${req.user.username}`, req.ip);
        res.json({ message: 'Link cancelled successfully' });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// add comment (only from instructor)
router.post('/user/:userId/workout/:workoutId/comments', (req, res) => {
    if (req.user.is_instructor !== 1) return res.status(403).json({ error: { field: 'general', message: 'Only instructor can comment' } });

    const userId = parseInt(req.params.userId);
    const workoutId = parseInt(req.params.workoutId);
    const { comment_text } = req.body;
    const { error } = createCommentSchema.validate(req.body);
    if (error) return res.status(400).json({ errors: handleJoiError(error) });

    if (!isAuthorized(req, userId)) return res.status(403).json({ error: { field: 'general', message: 'Unauthorized access' } });

    try {
        const workout = db.prepare(`SELECT id FROM workouts WHERE id = ? AND user_id = ?
        `).get(workoutId, userId);
        if (!workout) return res.status(404).json({ error: { field: 'general', message: 'Workout not found' } });
        
        // check if comment already exist for this workout
        const existingComment = db.prepare(`
            SELECT id FROM workout_comments WHERE workout_id = ? AND instructor_id = ?
        `).get(workoutId, req.user.id);
        if (existingComment) return res.status(409).json({ error: { field: 'general', message: 'You have already commented on this workout. Edit or delete it first.' } });

        db.prepare(`
            INSERT INTO workout_comments (workout_id, instructor_id, comment_text) VALUES (?, ?, ?)
        `).run(workoutId, req.user.id, comment_text);

        logEvent(req.user.id, 'comment_added', `Comment added to workout ${workoutId} for user ${userId}`, req.ip);
        res.json({ message: 'Comment added successfully' });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// update existing comment (only as the instructor)
router.put('/user/:userId/workout/:workoutId/comments/:commentId', (req, res) => {
    if (req.user.is_instructor !== 1) return res.status(403).json({ error: { field: 'general', message: 'Only instructor can update comments' } });

    const userId = parseInt(req.params.userId);
    const workoutId = parseInt(req.params.workoutId);
    const commentId = parseInt(req.params.commentId);
    const { comment_text } = req.body;
    const { error } = updateCommentSchema.validate(req.body);
    if (error) return res.status(400).json({ errors: handleJoiError(error) });

    if (!isAuthorized(req, userId)) return res.status(403).json({ error: { field: 'general', message: 'Unauthorized' } });

    try {
        const comment = db.prepare(`
            SELECT id FROM workout_comments WHERE id = ? AND workout_id = ? AND instructor_id = ?
        `).get(commentId, workoutId, req.user.id);
        if (!comment) return res.status(404).json({ error: { field: 'general', message: 'Comment not found or unauthorized' } });

        db.prepare(`
            UPDATE workout_comments SET comment_text = ? WHERE id = ?
        `).run(comment_text, commentId);

        logEvent(req.user.id, 'comment_updated', `Comment ${commentId} updated`, req.ip);
        res.json({ message: 'Comment updated successfully' });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// delete comments (both user and instructor can delete comments)
router.delete('/user/:userId/workout/:workoutId/comments/:commentId', (req, res) => {
    const userId = parseInt(req.params.userId);
    const workoutId = parseInt(req.params.workoutId);
    const commentId = parseInt(req.params.commentId);

    if (!isAuthorized(req, userId)) return res.status(403).json({ error: { field: 'general', message: 'Unauthorized' } });

    try {
        const workout = db.prepare(`
            SELECT id FROM workouts WHERE id = ? AND user_id = ?
        `).get(workoutId, userId);
        if (!workout) return res.status(404).json({ error: { field: 'general', message: 'Workout not found or unauthorized' } });

        const comment = db.prepare(`
            SELECT id, instructor_id FROM workout_comments WHERE id = ? AND workout_id = ?
        `).get(commentId, workoutId);
        if (!comment) return res.status(404).json({ error: { field: 'general', message: 'Comment not found or unauthorized' } });
        
        if (userId !== req.user.id && comment.instructor_id !== req.user.id) {
            return res.status(403).json({ error: { field: 'general', message: 'Unauthorized to delete this comment' } });
        }

        db.prepare(`DELETE FROM workout_comments WHERE id = ?`).run(commentId);

        logEvent(req.user.id, 'comment_deleted', `Comment ${commentId} deleted by user ${req.user.id}`, req.ip);
        res.json({ message: 'Comment deleted successfully' });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});

// view comment on a workout as the instructor
router.get('/user/:userId/workout/:workoutId/my-comments', (req, res) => {
    const userId = parseInt(req.params.userId);
    const workoutId = parseInt(req.params.workoutId);

    if (!isAuthorized(req, userId)) return res.status(403).json({ error: { field: 'general', message: 'Unauthorized' } });

    try {
        const workout = db.prepare(`
            SELECT id FROM workouts WHERE id = ? AND user_id = ?
        `).get(workoutId, userId);
        if (!workout) return res.status(404).json({ error: { field: 'general', message: 'Workout not found' } });

        const comment = db.prepare(`
            SELECT id, comment_text, created_at
            FROM workout_comments
            WHERE workout_id = ? AND instructor_id = ?
        `).get(workoutId, req.user.id);

        logEvent(req.user.id, 'my_comments_viewed', `Own comment viewed for workout ${workoutId} of user ${userId}`, req.ip);
        res.json({ comment });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: { field: 'general', message: 'Server error' } });
    }
});


module.exports = router;